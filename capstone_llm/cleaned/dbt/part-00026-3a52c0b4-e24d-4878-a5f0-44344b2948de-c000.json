{"title":"dbt macro to iterate over item in list within a sql call?","question_body":"<p>First off, I am a dbt backer! I love this tool and the versatility of it.</p>\n<p>When reading some of the <a href=\"https://docs.getdbt.com/reference/dbt-jinja-functions/adapter#drop_relation\" rel=\"noreferrer\">docs</a> I noticed that I might be able to do some meta work on my schemas every time I call a macro.</p>\n<p>One of those would be to clean up schemas.</p>\n<p>(<em>This has been edited as per discussion within the dbt slack</em>)</p>\n<ol>\n<li><p><code>dbt run-operation freeze</code> that would introspect all of the tables that would be written with dbt run but with an autogenerated hash (might just be timestamp). It would output those tables in the schema of my choice and would log the “hash” to console.</p>\n</li>\n<li><p><code>dbt run-operation unfreeze --args '{hash: my_hash}'</code> that would then proceed to find the tables written with that hash prefix and clean them out of the schema.</p>\n</li>\n</ol>\n","answer_body":"<p>I have created such a macro in an older version of dbt and it still works on 0.17.1.</p>\n<p>The macro below <code>item_in_list_query</code> is getting a list of <code>tables</code> from a separate macro <code>get_tables</code> (also below). That list of tables is then concatenated inside <code>item_in_list_query</code> to compose a desired SQL query and execute it. For demonstration there is also a model in which <code>item_in_list_query</code> is used.</p>\n<h3>item_in_list_query</h3>\n<pre><code>{% macro item_in_list_query() %}\n\n    {% set tables = get_tables() %}\n\n    {{ log(&quot;Tables: &quot; ~ tables, True) }}\n\n    {% set query %}\n        select id\n        from my_tables\n        {% if tables -%}\n            where lower(table_name) in {% for t in tables -%} {{ t }} {%- endfor -%}\n        {%- endif -%}\n    {% endset %}\n\n    {{ log(&quot;query: &quot; ~ query, True) }}\n\n    {# run_query returns agate.Table (https://agate.readthedocs.io/en/1.6.1/api/table.html). #}\n    {% set results = run_query(query) %}\n\n    {{ log(&quot;results: &quot; ~ results, True) }}\n\n    {# execute is a Jinja variable that returns True when dbt is in &quot;execute&quot; mode i.e. True when running dbt run but False during dbt compile. #}\n    {% if execute %}\n    {# agate.table.rows is agate.MappedSequence in which data that can be accessed either by numeric index or by key. #}\n    {% set results_list = results.rows %}\n    {% else %}\n    {% set results_list = [] %}\n    {% endif %}\n\n    {{ log(&quot;results_list: &quot; ~ results_list, True) }}\n    {{ return(results_list) }}\n\n{% endmacro %}\n\n</code></pre>\n<h3>get_tables</h3>\n<pre><code>{% macro get_tables() %}\n      {%- set tables = [\n          ('table1', 'table2')\n      ] -%}\n  {{return(tables )}}\n{% endmacro %}\n\n</code></pre>\n<h3>model</h3>\n<pre><code>{%- for item in item_in_list_query() -%}\n  {%- if not loop.first %} UNION ALL {% endif %}\n  select {{ item.id }}\n{%- endfor -%}\n\n</code></pre>\n"}
